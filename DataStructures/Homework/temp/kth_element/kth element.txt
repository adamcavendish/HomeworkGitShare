·	比如我們把整個數組叫做array，數組是從0~array_length-1的，也就是數組的長度是array_length。
·	我們要找到中間值，也就是找到第(k=n/2)小的數，以下的解釋基本可以從網上以及書上的kth_element算法中得到----即搜索查找第k小的數。

方法零：
·	原地排序完成後，找到array[array_length/2]的值。算法時間複雜度O(n*log(n))

方法一：
·	使用快速排序的思想：數據結構書P301有快速排序的示例。
	每一次對"基準位置"元素進行定位，需要O(n)的時間。
	如果它的位置小於k，就對右半部分進行方法一；如果位置大於k，就對左半部分進行方法一。
	
	·	時間複雜度：（參考P301你可以先看一下）
		T(n)
		<= c*n + T(n/2)
		<= c*n + c*(n/2) + T(n/4)
		<= c*n + c*(n/2) + c*(n/4) + T(n/8)
		...
		<= c*(n + n/2 + n/4 + ... + 1) + T(1)
		根據等比數列公式，可以求得: ( 注：其中項數=log(2, n) )
		= c*( n*( (1-(1/2)^log(2,n))/(1-(1/2)) ) ) + T(1)
		= c*(2*n-2) + T(1)
		= c'n + T(1) - 2*c
		= O(n)
		所以時間複雜度是O(n)級別的。
	簡單實現參見quicksort_impl.cpp
	
方法二：
·	使用最小堆————堆排序完成前k次即可。此時最小的元素逆向從array_length-1開始，直到array_length-1-k結束
	·	時間複雜度：
		建立堆O(n)
		每次刪除的維護時間O(log(2,n))
		總時間：O(n) + k*O(log(2,n))
		當n較大時，O(n)佔主導地位
		時間複雜度爲O(n)

方法三：
·	首先给定一个K个大小的数组b，然后复制数组a中的前K个数到数组b中，
	将这K个数当成数组a的前K个最小值，对数组b创建最大堆，这时候再次比较数组a中的其他元素，
	如果其他元素小于数组b的最大值（堆顶），则将堆顶的值进行替换，并重新创建最大堆。
	这样遍历一次数组就找到了前K个最小元素。这种方法运用了额外的内存空间，特别当选择的K值比较大时，
	这种方法有待于权衡一下。
	
    这种方法对于海量数据来说是有较好的作用，对于海量数据不能全部存放在内存中，这时候创建一个较小的数组空间，
    然后创建最大堆，从硬盘中读取其他的数据，进而实现前K个数据的查找。
    
方法四：
·	劃分樹————網上的資料本身也挺少的。時間也不多所以我也沒有怎麼看。
·	參考：http://blog.163.com/tonyshaw@yeah/blog/static/142021718201035102322338/

想看一些神奇的代碼的話，C++自己有kth_element的實現。(應該是gcc編譯器版本至少高於4.6才行）
#include <algorithm> ---> 即在這個頭文件中你可以找到kth_element的算法

